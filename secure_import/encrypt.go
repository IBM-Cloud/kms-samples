package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"os"
)

// takes in key material (key) and nonce (value)
func encryptNonce(key, value string) (string, string, error) {
	var cipherText []byte
	// base64 decode the input
	keyMat, err := base64.StdEncoding.DecodeString(key)
	if err != nil {
		return "", "", fmt.Errorf("Failed to decode key material: %s", err)
	}
	nonce, err := base64.StdEncoding.DecodeString(value)
	if err != nil {
		return "", "", fmt.Errorf("Failed to decode nonce: %s", err)
	}
	// set up aes-gcm
	block, err := aes.NewCipher(keyMat)
	if err != nil {
		return "", "", err
	}
	aesgcm, err := cipher.NewGCM(block)
	if err != nil {
		return "", "", err
	}
	// create random iv for security to pass into aes-gcm
	iv := make([]byte, 12)
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		panic(err.Error())
	}
	cipherText = aesgcm.Seal(nil, iv, nonce, nil)

	// base64 encode so it's already prepared to be passed into a request
	return base64.StdEncoding.EncodeToString(cipherText), base64.StdEncoding.EncodeToString(iv), nil
}

func main() {
	var nonce string
	var key string
	flag.StringVar(&nonce, "nonce", "", "Nonce generated by Key Protect service")
	flag.StringVar(&key, "key", "", "Key material that you want to import into the Key Protect service")
	flag.Parse()
	if nonce == "" || key == "" {
		fmt.Println("ERROR: '-nonce' and '-key' must both be defined")
		os.Exit(1)
	}
	encryptedNonce, iv, err := encryptNonce(key, nonce)
	if err != nil {
		fmt.Printf("ERROR: %s", err)
		os.Exit(1)
	}
	// set up values to print as proper json
	encryptionValues := map[string]interface{}{
		"encryptedNonce": encryptedNonce,
		"iv":             iv,
	}
	js, err := json.MarshalIndent(encryptionValues, "", "	")
	if err != nil {
		panic(err.Error())
	}
	fmt.Printf("%s\n", js)
}
